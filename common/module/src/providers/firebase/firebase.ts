import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { BehaviorSubject } from 'rxjs';
// tslint:disable-next-line
// import { firestore } from 'firebase';
import * as firebase from 'firebase/app';
import { firestore } from 'firebase/app';
import 'firebase/database';
import 'firebase/auth';
import 'firebase/firestore';
import 'firebase/storage';
import { GoaaaResources, FirebaseResourceConfig } from './resources';
import { FirebaseUidConfig } from '../../models/firebase/firebase-uid-config.model';
import { GoaaaEnvironment } from '../../environments/environment'

/**
 * Used to store a Firebase/Firestore database reference and it's associated URL.
 */
class FirebaseDatabaseDescriptor {
    /**
     * The URL that points to a specific Firebase/Firestore database. This
     * can be found in the [Firebase Console]{@link https://console.firebase.google.com}.
     */
    url: string;
    /**
     * The actual database reference object that is used to execute database operations.
     */
    ref: any;
    /**
     * The type of database reference for this descriptor (firestore or realtime)
     */
    type: string;

    /**
     * Builds and initializes a descriptor for a Firebase/Firestore database.
     * @param url The URL that points to a specific Firebase/Firestore database. This
     * can be found in the [Firebase Console]{@link https://console.firebase.google.com}.
     * @param ref The actual database reference object that is used to execute database operations.
     */
    constructor(url: string, type: string, ref: any) {
        this.url = url;
        this.type = type;
        this.ref = ref;
    }

    /**
     * Checks if two database descriptors are eqivalent by comparing the following parameters:
     * url, type
     * @param other A second project descriptor to compare to.
     */
    matches(other: any): boolean {
        return this.url === other.url &&
            this.type === other.type;
    }
}

/**
 * Used to store a Firebase/Firestore project reference and it's associated URL.
 * For the realtime database, there can be multiple databases per project.
 */
export class FirebaseProjectDescriptor {
    /**
     * Part of the credentials for a web application that can be retrieved from
     *  the Firebase console.
     */
    storageBucket: string = null;
    /**
     * Part of the credentials for a web application that can be retrieved from
     *  the Firebase console.
     */
    projectId: string = null;

    /**
     * The actual project reference object that is used to access realtime
     *  database / firestore instances.
     */
    ref: any = null;

    /**
     * Builds and initializes a descriptor for a Firebase/Firestore project.
     * @param other An object containing any of the classes parameters.
     */
    constructor(other?: any) {
        if (other !== undefined && other !== null) {
            for (let key in this) {
                if (other.hasOwnProperty(key)) {
                    this[key] = other[key];
                }
            }
        }
    }

    /**
     * Checks if two project descriptors are eqivalent by comparing the following parameters:
     * storageBucket, projectId
     * @param other A second project descriptor to compare to.
     */
    matches(other: any): boolean {
        return this.storageBucket === other.storageBucket &&
            this.projectId === other.projectId;
    }
}

/**
 * Used to store a Firebase/Firestore project reference and it's associated URL.
 * For the realtime database, there can be multiple databases per project.
 */
class FirebaseProjectDescriptorEx extends FirebaseProjectDescriptor {
    /**
     * Part of the credentials for a web application that can be retrieved from
     *  the Firebase console.
     */
    apiKey: string = null;
    /**
     * Part of the credentials for a web application that can be retrieved from
     *  the Firebase console.
     */
    authDomain: string = null;

    /**
     * Store the descriptors for all of the databases associated with this project.
     */
    databases: FirebaseDatabaseDescriptor[] = [];

    /**
     * The custom sign-in token that is generated by the AAA Firebase authentication API.
     *
     * TODO: Add the API documentation link.
     */
    signInToken: string = null;

    /**
     * The promise used when signing in to Firebase.
     *
     * All operations that access the project will build off of this promise to ensure
     * that all operations wait for sign-in.
     */
    signInPromise: Promise<FirebaseProjectDescriptorEx> = Promise.resolve(null);

    /**
     * Builds and initializes a descriptor for a Firebase/Firestore project.
     * @param config An object containing the following parameters: apiKey, authDomain,
     *  storageBucket, projectId.
     */
    constructor(config: any) {
        super(config);
        this.apiKey = config.apiKey;
        this.authDomain = config.authDomain;
    }

    /**
     * Checks if two project descriptors are eqivalent by comparing the following parameters:
     * apiKey, authDomain, storageBucket, projectId
     * @param other A second project descriptor to compare to.
     */
    matches(other: any): boolean {
        return this.apiKey === other.apiKey &&
            this.authDomain === other.authDomain &&
            this.storageBucket === other.storageBucket &&
            this.projectId === other.projectId;
    }
}

/**
 * Used to store a Firebase/Firestore resource reference and it's associated path.
 */
class FirebaseRefDescriptor {
    /**
     * The resource reference object that can be used to create listeners and set/update data.
     */
    resRef: any;

    /**
     * The type of the reference ('object' or 'list').
     */
    refType: string;

    /**
     * The path to the resource in the database.
     */
    path: string;

    /**
     * The reference to the database object that the resource exists in.
     */
    dbRef: any;

    /**
     * The type of the database that the resource exists in ('realtime' or 'firestore').
     */
    dbType: string;

    /**
     * Builds and initializes a descriptor for a Firebase/Firestore resource.
     * @param dbType The type of the database that the resource exists in ('realtime'
     *  or 'firestore').
     * @param refType The type of the reference ('object' or 'list').
     * @param path The path to the resource in the database.
     */
    constructor(dbType: string, refType: string, path: string) {
        this.dbType = dbType;
        this.refType = refType;
        this.path = path;
        this.resRef = null;
        this.dbRef = null;
    }
}

/**
 * Provider for accessing resources from Firebase realtime databases and Firestore.
 */
@Injectable()
export class GoaaaFirebaseProvider {

    /**
     * Map containing the GET url for accessing the connection details
     * associated with each of the resources defined in the GoaaaResources enum.
     */
    private firebaseResourceConfiguration = null;

    /**
     * Stores the user ID that is used to generate sign-in tokens.
     */
    private uid = new BehaviorSubject<string>(null);

    /**
     * Stores the configuration details that are required to get a UID.
     */
    private uidConfig: FirebaseUidConfig;

    /**
     * Holds descriptors for all of the active Firebase projects.
     */
    private projects: FirebaseProjectDescriptorEx[] = [];

    /**
     * Lazy loaded storage for resources.
     *
     * When a resource is accessed for the first time,
     * the AAA Firebase Connection API is called and the
     * descriptors are created. The resource reference is then
     * stored in this object so it can be reused without
     * any additional API calls.
     */
    private resources = {};

    private configPromise: Promise<void> = Promise.resolve();

    /**
     * Constructor for the GoaaaFirebaseProvider.
     * @param http Provider to enable making REST API calls.
     */
    constructor(private http: HttpClient, private env: GoaaaEnvironment) {

        const requestBase = `${this.env.endpoints.firebase}/connection?resource=`;
        this.firebaseResourceConfiguration = new Map<string, FirebaseResourceConfig>([
            [GoaaaResources.TrucksActive, new FirebaseResourceConfig(`${requestBase}trucks-active`)],
            [GoaaaResources.TrucksRealtime, new FirebaseResourceConfig(`${requestBase}trucks-realtime`)],
            [GoaaaResources.TrucksDetail, new FirebaseResourceConfig(`${requestBase}trucks-detail`)],
            [GoaaaResources.ServiceCallsDetail, new FirebaseResourceConfig(`${requestBase}service-calls-detail`)],
            [GoaaaResources.DriversDetail, new FirebaseResourceConfig(`${requestBase}drivers-detail`)]
        ]);
    }

    configure(config: FirebaseUidConfig): Promise<void> {
        // Check for differences against the current configuration if it exists; If it is the same, do nothing
        if (!this.configPromise || JSON.stringify(config) !== JSON.stringify(this.uidConfig)) {
            // Store the new configuration
            this.uidConfig = config;

            this.configPromise = new Promise((resolve, reject) => {
                this.http.post<any>(`${this.env.endpoints.firebase}/uid`, this.uidConfig)
                    .subscribe((result) => {
                        console.log(`Got UID of ${result.uid}`);
                        this.uid.next(result.uid);
                        resolve();
                    },
                        (err) => {
                            reject(err);
                        });
            });
        }

        return this.configPromise;
    }

    /**
     * Overwrites the data for the specified resource.
     * @param resource One of the enumerated resources in resources.ts
     * @param key If the base resource is a list, the key can be used to refine to an object.
     * Ex. /trucks => /trucks/{serial} where {serial} is defined by the key parameter.
     * @param param The data to be written.
     */
    set(resource: GoaaaResources, key: string, param: any) {
        return new Promise((resolve, reject) => {
            this.getResource(resource, key)
                .then((ref) => {
                    ref.resRef.set(param, (err) => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve();
                        }
                    });
                })
                .catch((err) => {
                    reject(err);
                });
        });
    }

    /**
     * Provides access to the database object (firestore or rtdb) associated with a
     *  resource for more advanced operations.
     * @param resource The specific enumerated resource to get the database for.
     */
    getDatabaseAndPath(resource: GoaaaResources) {
        return new Promise((resolve, reject) => {
            this.getResource(resource, null)
                .then((ref) => {
                    resolve({ ref: ref.dbRef, type: ref.dbType, path: ref.path });
                })
                .catch((err) => {
                    reject(err);
                });
        });
    }

    /**
     * Provides access to the project reference associated with a
     *  resource for more advanced operations.
     * @param resource The specific enumerated resource to get the project for.
     */
    getProject(resource: GoaaaResources): Promise<FirebaseProjectDescriptor> {
        return new Promise((resolve, reject) => {

            this.getConnectionDetailsByResource(resource)
                .then((resourceConfig) => {

                    // Get the project reference
                    return this.getOrCreateProject(resourceConfig.dbConfig)
                        .then((ref) => {

                            // If there is a key, get the refined resource reference before
                            // passing to resolve
                            resolve(new FirebaseProjectDescriptor(ref));
                        });
                })
                .catch((err) => {
                    reject(err);
                });
        });
    }

    private convertTimeStamps(object: any): any {
        for (let field in object) {
            if (object[field] instanceof Object) {
                if (object[field] instanceof firestore.Timestamp) {
                    const stamp: firestore.Timestamp = object[field];
                    object[field] = stamp.toDate().toISOString();
                } else {
                    // Call recursively to handle nested objects
                    this.convertTimeStamps(object[field]);
                }
            }
        }
    }

    /* tslint:disable:max-line-length */
    /**
     * Adds a listener for a specific resource event.
     *
     * See the following documentation for more information.
     * <ul>
     * <li><a href="https://firebase.google.com/docs/reference/js/firebase.database.Reference">
     * https://firebase.google.com/docs/reference/js/firebase.database.Reference</a></li>
     * <li><a href="https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots">
     * https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots</a></li>
     * </ul>
     *
     * @param resource One of the enumerated resources in resources.ts
     * @param key If the base resource is a list, the key can be used to refine to an object.
     * Ex. /trucks => /trucks/{serial} where {serial} is defined by the key parameter.
     * @param eventType Supported event types: 'value', 'child_added', 'child_changed',
     *  'child_removed', 'child_moved'
     * @param callback Callback method executed when the event occurs. Function spec:
     *  callback(resource, event, snapshot)
     */
    /* tslint:enable */
    addListener(resource: GoaaaResources, key: string, eventType: string, callback: any):
        Promise<any> {

        // Define a function to do any common preprocessing on the data
        let callbackWrapper = (data) => {
            // Handle timestamp conversions
            this.convertTimeStamps(data);

            callback(data);
        };

        return new Promise((resolve, reject) => {
            this.getResource(resource, key)
                .then((ref) => {
                    let unsubscribe = null;
                    switch (ref.dbType) {
                        case 'realtime': {
                            // Create the listener and store the reference to the anonymous
                            // callback function
                            const callbackRef = ref.resRef.on(eventType, (snapshot) => {
                                // Call val() on the snapshot so only the data is passed back
                                // to the user
                                // NOTE: Wrapper not needed because RTDB doesn't need type conversions
                                callback(snapshot.val());
                            });
                            // Define the unsubscribe function
                            // Removing the listener requires that the same callback reference
                            // is passed in
                            unsubscribe = () => {
                                ref.resRef.off(eventType, callbackRef);
                            };
                            break;
                        }
                        case 'firestore': {
                            // Child moved is only handled by the realtime database
                            if (eventType === 'child_moved') {
                                reject(new Error('Unsupported event type'));
                                return;
                            }
                            switch (ref.refType) {
                                case 'object': {
                                    // Since this is an object and not a list, added and removed
                                    // events are not applicable
                                    if (!(eventType === 'value' ||
                                        eventType === 'child_modified')) {
                                        reject(new Error('Unsupported event type'));
                                        return;
                                    }
                                    // The call to set up a snapshot listener also returns
                                    // a function that can be used to unsubscribe
                                    unsubscribe = ref.resRef.onSnapshot(
                                        (snapshot) => {
                                            callbackWrapper(snapshot.data());
                                        },
                                        (err) => {
                                            reject(err);
                                        });
                                    break;
                                }
                                case 'list': {
                                    // Map the input event types to Firestore change types
                                    let allowedOperations = '';
                                    switch (eventType) {
                                        case 'child_added': {
                                            allowedOperations = 'added';
                                            break;
                                        }
                                        case 'child_changed':
                                        case 'value': {
                                            allowedOperations = 'modified';
                                            break;
                                        }
                                        case 'child_removed': {
                                            allowedOperations = 'removed';
                                            break;
                                        }
                                    }
                                    // The call to set up a snapshot listener also returns a
                                    // function that can be used to unsubscribe
                                    unsubscribe = ref.resRef.onSnapshot(
                                        (snapshot) => {
                                            snapshot.docChanges().forEach((change) => {
                                                if (change.type === allowedOperations) {
                                                    callbackWrapper(change.doc.data());
                                                }
                                            });
                                        },
                                        (err) => {
                                            reject(err);
                                        });
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    // Pass back the unsubscribe function so the user is able to remove the listener
                    resolve(unsubscribe);
                })
                .catch((err) => {
                    reject(err);
                });
        });
    }

    /**
     * Builds a new reference descriptor from a base resource reference.
     * Ex. /trucks => /trucks/{serial} where {serial} is defined by the key parameter.
     * @param ref The base resource reference to be refined.
     * @param key If the key is null, ref will be returned as is.
     */
    private refineResourceWithKey(ref: FirebaseRefDescriptor, key: string): FirebaseRefDescriptor {
        if (key) {
            // When a key is specified, it is assumed that the reference type is an object
            // rather than a list. The type is changed here.
            return this.buildResource(ref.dbRef, { type: 'object', path: `${ref.path}/${key}` },
                ref.dbType);
        }
        return ref;
    }

    /**
     * Retrieves a Firebase RTDB/Firestore reference for the specified enumerated resource.
     * @param resource One of the enumerated resources in resources.ts
     * @param key If the base resource is a list, the key can be used to refine to an object.
     * @return {Promise<FirebaseRefDescriptor>} A promise that provides the ref descriptor
     *  when it resolves.
     */
    private getResource(resource: GoaaaResources, key: string): Promise<FirebaseRefDescriptor> {
        return new Promise((resolve, reject) => {
            // If the resource has already been created, return it
            if (this.resources.hasOwnProperty(resource)) {
                // If a key was specified, use the details of the base resource and
                // build a new resource descriptor that includes the key
                resolve(this.refineResourceWithKey(this.resources[resource], key));
                return;
            }

            // =========================================
            // Otherwise, create the resource
            // =========================================
            console.log(`Getting connection details for ${resource} resource`);
            this.getConnectionDetailsByResource(resource)
                .then((resourceConfig) => {

                    // Get the database reference
                    return this.getOrCreateDatabase(resourceConfig.dbConfig)
                        .then((dbRef) => {

                            // Build the reference descriptor for the resource root
                            this.resources[resource] = this.buildResource(dbRef,
                                resourceConfig.resource, resourceConfig.dbConfig.type);

                            // If there is a key, get the refined resource reference before
                            // passing to resolve
                            resolve(this.refineResourceWithKey(this.resources[resource], key));
                        });
                })
                .catch((err) => {
                    reject(err);
                });
            // =========================================
        });
    }

    /**
     * Handles the creation of the ref descriptor according to the database and reference type.
     * @param dbRef The reference to the database (not the database descriptor).
     * @param resourceDetails An object that contains the resource path and type.
     * @param dbType The database type (realtime or firestore).
     */
    private buildResource(dbRef: any, resourceDetails: any, dbType: string): FirebaseRefDescriptor {

        const descriptor = new FirebaseRefDescriptor(dbType, resourceDetails.type,
            resourceDetails.path);
        descriptor.dbRef = dbRef;

        // Build the resource based on the type
        switch (dbType) {
            case 'realtime': {
                switch (resourceDetails.type) {
                    case 'object':
                    case 'list': {
                        descriptor.resRef = dbRef.ref(resourceDetails.path);
                        break;
                    }
                }
                break;
            }

            case 'firestore': {
                switch (resourceDetails.type) {
                    case 'object': {
                        descriptor.resRef = dbRef.doc(resourceDetails.path);
                        break;
                    }

                    case 'list': {
                        descriptor.resRef = dbRef.collection(resourceDetails.path);
                        break;
                    }
                }
                break;
            }
        }
        return descriptor;
    }

    private getSignInToken(authDomain: string): Promise<string> {
        return new Promise((resolve, reject) => {
            this.uid.subscribe((uid) => {
                // Make sure we have a UID before making the sign-in token request
                if (uid !== null) {
                    this.http.post<any>(`${this.env.endpoints.firebase}/signin-token`, {
                        uid: uid,
                        authDomain: authDomain
                    })
                        .subscribe((result) => {
                            console.log(`Got sign-in token for ${authDomain}`);
                            resolve(result.token);
                        },
                            (err) => {
                                reject(err);
                            });
                }
            });
        });
    }

    /**
     * Retrieves or creates a firebase project descriptor based on the configuration.
     *
     * If no matching project descriptor is available, one will be created.
     * This method also handles the retrieval of a sign-in token and the
     * execution of the firebase sign-in process.
     * @param config An object containing the following parameters: apiKey, authDomain, storageBucket, projectId.
     */
    private getOrCreateProject(config: any): Promise<FirebaseProjectDescriptorEx> {

        // Search for any existing matching projects
        for (var project of this.projects) {
            if (project.matches(config)) {
                return project.signInPromise;
            }
        }

        // If no matching project was found, create it
        // Create a new descriptor
        var projectDescriptor = new FirebaseProjectDescriptorEx(config);

        // Add the project descriptor to the array
        this.projects.push(projectDescriptor);

        projectDescriptor.signInPromise = projectDescriptor.signInPromise
            .then(() => {
                // Create the project instance
                projectDescriptor.ref = firebase.initializeApp(config, config.projectId);

                // Get the sign-in token and then sign in with it
                return this.getSignInToken(config.authDomain)
                    .then((token) => {
                        projectDescriptor.signInToken = token;
                        return projectDescriptor.ref.auth()
                            .signInWithCustomToken(token);
                    })
                    .then(res => {
                        console.log(res);
                        return Promise.resolve(projectDescriptor);
                    })
            });
        return projectDescriptor.signInPromise;
    }

    /**
     * Retrieves or creates the database reference.
     *
     * @param config An object containing the following parameters: apiKey, authDomain, storageBucket, projectId.
     */
    private getOrCreateDatabase(config: any): Promise<any> {
        return new Promise((resolve, reject) => {
            this.getOrCreateProject(config)
                .then(projectDescriptor => {

                    // Search for an existing matching database associated with the project
                    var databaseRef = null;
                    for (var database of projectDescriptor.databases) {
                        if (database.url === config.databaseURL && database.type === config.type) {
                            databaseRef = database.ref;
                            break;
                        }
                    }

                    // If no matching database was found, get the database ref
                    if (databaseRef === null) {
                        var databaseDescriptor = new FirebaseDatabaseDescriptor(
                            config.databaseURL,
                            config.type,
                            config.type === 'firestore' ? projectDescriptor.ref.firestore() : projectDescriptor.ref.database(config.databaseURL)
                        );

                        if (config.type === 'firestore') {
                            const settings = {/* your settings... */ timestampsInSnapshots: true };
                            databaseDescriptor.ref.settings(settings);
                        }

                        // Store the database ref with its associated project
                        projectDescriptor.databases.push(databaseDescriptor);
                        databaseRef = databaseDescriptor.ref;
                    }

                    resolve(databaseRef);
                })
                .catch((err) => {
                    reject(err);
                });
        });
    }

    /**
     * Calls the backend API for getting the configuration details to make a native
     *  Firebase SDK connection.
     * @param resource One of the enumerated resources in resources.ts
     */
    private getConnectionDetailsByResource(resource: GoaaaResources): Promise<any> {
        return new Promise((resolve, reject) => {
            this.http.get<any>(this.firebaseResourceConfiguration.get(resource).url)
                .subscribe((connection) => {
                    // TEMPORARY - Override resource type to be a list
                    connection.resource.type = 'list';
                    if(resource === GoaaaResources.TrucksRealtime){
                        // TODO Modify the backend to change this path
                        // Better yet would be to modify the backend to pull the paths from a
                        // config section in Firestore
                        connection.resource.path = '/truckLocationsBySerial';
                    }
                    console.log(`Connection details: ${JSON.stringify(connection)}`);
                    resolve(connection);
                },
                    (err) => {
                        reject(err);
                    });
        });
    }
}
